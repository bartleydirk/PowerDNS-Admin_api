#!/usr/bin/env python
"""A script to clean up the powerdns data."""

# import os
import sys
import re
import ipaddress
from pprint import pprint  # , pformat

# pylint: disable=E0401,R0903
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine, Column, INTEGER, VARCHAR, SmallInteger, func, desc
from sqlalchemy.orm import sessionmaker


from admin_api.clientapi import Clientapi

DOAPI = True
if DOAPI:
    CLIAPI = Clientapi()
re_slotspot = re.compile(r'slot.*\.spotx\.')
re_addrarpa = re.compile(r'\.in-addr\.arpa')
re_ip6arpa = re.compile(r'ip6.arpa')
re_ipdash = re.compile(r'^ip-')
re_ip4start = re.compile(r'^([0-9\-]*).*')
re_dashend = re.compile(r'(.*)\-$')


Base = declarative_base()

privatelist = []
privatelist.append(ipaddress.ip_network(u'192.168.0.0/16'))
privatelist.append(ipaddress.ip_network(u'172.16.0.0/12'))
privatelist.append(ipaddress.ip_network(u'10.0.0.0/8'))

engine = create_engine('mysql://pdns_user:ie0weeR1_jae3sai@dnstest2/pdns')
Session = sessionmaker(bind=engine)
# create a Session
session = Session()
checkdomain = 'pop'


def intsafe(inval):
    """ turn a value into a integer without epic fail """
    val = inval
    try:
        val = int(val)
    except ValueError:
        val = None
    return val


def isprivate(addr):
    """Is an ip address a private ip address."""
    retval = False
    # pylint: disable=E0602
    addr = ipaddress.ip_address(unicode(addr))
    for subnet in privatelist:
        if addr in subnet:
            retval = True
            break
    return retval


def addr_to_arpa(addr):
    """Take address ipv4, return in-addr.arpa."""
    test = addr.split('.')
    if len(test) == 4:
        return "%s.%s.%s.%s.in-addr.arpa" % (test[3], test[2], test[1], test[0])


def apra_to_addr(arpa):
    """Take the arpa return addr."""
    if re_ip6arpa.search(arpa):
        print('returning none %s' % (arpa))
        return None
    arpaless = re_addrarpa.sub('', arpa)
    test = arpaless.split('.')
    if len(test) == 4:
        return "%s.%s.%s.%s" % (test[3], test[2], test[1], test[0])


class Domains(Base):
    """Model for the domains table."""
    __tablename__ = 'domains'
    id = Column(INTEGER(), primary_key=True, nullable=False)
    name = Column(VARCHAR(length=255))
    master = Column(VARCHAR(length=128))
    last_check = Column(INTEGER())
    type = Column(VARCHAR(length=6))
    notified_serial = Column(INTEGER())
    account = Column(VARCHAR(length=40))

    def __repr__(self):
        return '%s %s %s' % (self.id, self.type, self.name)


class Records(Base):
    """Model for the records database table."""
    __tablename__ = 'records'
    id = Column(INTEGER(), primary_key=True, nullable=False)
    domain_id = Column(INTEGER())
    name = Column(VARCHAR(length=255))
    type = Column(VARCHAR(length=10))
    content = Column(VARCHAR(length=64000))
    ttl = Column(INTEGER())
    prio = Column(INTEGER())
    change_date = Column(INTEGER())
    disabled = Column(SmallInteger())
    ordername = Column(VARCHAR(length=255))
    auth = Column(SmallInteger())

    def __repr__(self):
        return '%s %s %s %s' % (self.id, self.type, self.name, self.content)


def build_arecdict(chkdom='pop'):
    """Method to build forward and reverse dictionaries of "A" records."""
    sqry_fw = session.query(Domains.id)\
                     .filter(Domains.name == chkdom)

    qry = session.query(Records)\
                 .filter(Records.type == 'A')\
                 .filter(Records.domain_id == sqry_fw)

    ipkey_forw_dct = {}
    namekey_forw_dct = {}
    for rec in qry:
        if rec.content not in ipkey_forw_dct:
            ipkey_forw_dct[rec.content] = [rec.name]
        else:
            ipkey_forw_dct[rec.content].append(rec.name)
        if rec.name not in namekey_forw_dct:
            namekey_forw_dct[rec.name] = [rec.content]
        else:
            namekey_forw_dct[rec.name].append(rec.content)

    return (ipkey_forw_dct, namekey_forw_dct)


def build_ptr_dict():
    """Method to build forward and reverse dictionaries of "A" records."""
    qry = session.query(Records)\
                 .filter(Records.type == 'PTR')\

    ipkey_dct = {}
    namekey_dct = {}
    for rec in qry:
        ipaddr = apra_to_addr(rec.name)
        if ipaddr:
            if ipaddr not in ipkey_dct:
                ipkey_dct[ipaddr] = [rec.content]
            else:
                ipkey_dct[ipaddr].append(rec.content)
            if rec.content not in namekey_dct:
                namekey_dct[rec.content] = [ipaddr]
            else:
                namekey_dct[rec.content].append(ipaddr)
        else:
            print("arpa conversion issue %s %s" % (rec.name, rec.content))

    return (namekey_dct, ipkey_dct)


def fix_arecs_tocnames():
    """A method to find 'A' records that point to the same ip and ask the user to change all but one to CNAMEs"""
    arec_fwd, _ = build_arecdict()
    print("Attempting fix of a records pointing to same ip by changing to cname %s" % (len(arec_fwd)))
    # pylint: disable=E0602,R1702
    for addr in arec_fwd:
        namelist = arec_fwd[addr]

        if len(namelist) > 1:
            print("two A's pointing to same ipaddr %s %s" % (addr, namelist))
            foundat = -1
            usethisname = None
            for (cnter, name_) in enumerate(namelist):
                if re_slotspot.search(name_):
                    foundat = cnter
                    usethisname = name_
            options = []
            for (cnter, name_) in enumerate(namelist):
                thisbe = ""
                if foundat == cnter:
                    thisbe = "< -- -- --"
                print("%s %s %s" % (cnter, name_, thisbe))
                options.append(cnter)
            if foundat >= 0:
                for (cnter, name_) in enumerate(namelist):
                    if cnter != foundat:
                        # STEP ONE
                        print("ONE Changing %s to a cname to %s" % (name_, usethisname))
                        if DOAPI:
                            CLIAPI.perform_delete(name=name_, rectype='A')
                            CLIAPI.perform_add(name=name_, content=usethisname, rectype='CNAME')
            else:
                thecommand = None
                while thecommand not in options:
                    thecommand = intsafe(raw_input('Pick one '))
                usethisname = namelist[thecommand]
                for (cnter, name_) in enumerate(namelist):
                    if cnter != thecommand:
                        # STEP TWO
                        print("TWO Changing %s to a cname to %s" % (name_, usethisname))
                        if DOAPI:
                            CLIAPI.perform_delete(name=name_, rectype='A')
                            CLIAPI.perform_add(name=name_, content=usethisname, rectype='CNAME')


# now we have gotten changed to cnames all the appropriate records.
def fixrev_fromarec():
    """Knowing all arecs in pop, fix the reverses that do not correlate."""
    arec_frwd, _ = build_arecdict()
    print("Attempting fix of reverse records not being what the a record says they should be")
    issue_dct = {}
    counter = 0
    for addr in arec_frwd:
        arpa = addr_to_arpa(addr)
        fname = arec_frwd[addr][0]
        revqry = session.query(Records)\
                        .filter(Records.name == arpa)\
                        .filter(Records.type == 'PTR')
        revrecs = revqry.all()
        if not revrecs:
            if isprivate(addr):
                counter += 1
                print('%s No reverse found %s %s %s' % (counter, fname, addr, arpa))
                if DOAPI:
                    CLIAPI.fixrev(hostname=fname, revname=arpa)
        elif len(revrecs) == 1:
            if revrecs[0].content == fname:
                #  Woo Hoo, we be good
                pass
            else:
                issue_dct[arpa] = [fname]
                print("will fix reverse %s to PTR to %s" % (arpa, fname))
                if DOAPI:
                    CLIAPI.fixrev(hostname=fname, revname=arpa)
        else:
            counter += 1
            # print('%s %s %s  ..  "greater than 1"  ..  %s' % (counter, rec, rev, len(revrecs)))
    pprint(issue_dct)


def check_ptrs():
    """Check the PTR records make sure they do not point to nothing."""
    perfectcnt = 0
    _, ipkey_dct = build_ptr_dict()
    ipkey_forw_dct, namekey_forw_dct = build_arecdict()
    print("back from build_ptr_dict")
    counter = 0
    for cnter, ipaddr in enumerate(ipkey_dct):
        if not ipkey_dct[ipaddr]:
            print("Hmmmmm %s %s" % (ipaddr, ipkey_dct[ipaddr]))
        elif len(ipkey_dct[ipaddr]) != 1:
            print("len not 1 %s %s" % (ipaddr, ipkey_dct[ipaddr]))
        else:
            # print "namelist is %s" % ipkey_dct[ipaddr]
            if not re_ipdash.search(ipkey_dct[ipaddr][0]):
                fw_namelst = 'xxx'
                if ipaddr in ipkey_forw_dct:
                    fw_namelst = ipkey_forw_dct[ipaddr]
                fw_iplist = 'xxx'
                if ipkey_dct[ipaddr][0] in namekey_forw_dct:
                    fw_iplist = namekey_forw_dct[ipkey_dct[ipaddr][0]]

                #nametolist = namekey_dct[]

                if ipkey_dct[ipaddr] == fw_namelst and ipaddr == fw_iplist[0]:
                    perfectcnt += 1
                else:
                    counter += 1
                    qwer = ''
                    #print ipkey_dct[ipaddr][0]
                    asdf = re_ip4start.sub(r'\g<1>', ipkey_dct[ipaddr][0])
                    if asdf:
                        qwer = re_dashend.sub(r'\g<1>', asdf)
                    print("%s %s %s %s %s %s '%s'" % (cnter, counter, ipaddr, ipkey_dct[ipaddr], fw_namelst, fw_iplist, qwer))
    print("perfectcnt %s" % (perfectcnt))

def heinous_repeats_nonapi():
    """Find the heinous repeats
    | id    | domain_id | name                      | type | content                                      | ttl  | prio | change_date | disabled | ordername | auth |
    | 16393 |        50 | 199.0.17.172.in-addr.arpa | PTR  | 172-17-0-199-wifi-mgmt.hq.booyahnetworks.com | 3600 |    0 |        NULL |        0 | NULL      |    1 |
    | 16453 |        50 | 199.0.17.172.in-addr.arpa | PTR  | 172-17-0-199-wifi-mgmt.hq.booyahnetworks.com | 3600 |    0 |        NULL |        0 | NULL      |    1 |
    """
    qry1 = session.query(Records.domain_id, Records.name, Records.content, Records.type, func.count().label('cnt'))\
                  .group_by(Records.domain_id, Records.name, Records.content, Records.type)\
                  .subquery('qry1')
    qry2 = session.query(qry1)\
                  .filter(qry1.c.cnt > 1)
    for item in qry2:
        #print "%s %s %s %s" % (item.domain_id, item.name, item.content, item.type)
        mdll = session.query(Records)\
                      .filter(Records.domain_id == item.domain_id)\
                      .filter(Records.name == item.name)\
                      .filter(Records.content == item.content)\
                      .filter(Records.type == item.type)\
                      .order_by(desc(Records.id))\
                      .first()
        print "%s" % mdll
        session.delete(mdll)
    session.commit()


if __name__ == '__main__':
    # fix_arecs_tocnames()
    # fixrev_fromarec()

    _, rev_content = build_arecdict()
    for name in rev_content:
        if len(rev_content[name]) > 1:
            print("more than one address ?? %s %s" % (name, rev_content[name]))
    # pprint(rev_content)

    check_ptrs()
    #heinous_repeats_nonapi()
    sys.exit()
